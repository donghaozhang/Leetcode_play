# 全子集问题解析

## 问题描述
给定一个不含重复元素的整数数组 nums，返回该数组所有可能的子集。解集不能包含重复的子集。

例如：
```
输入: nums = [1,2,3]
输出:
[
  [],
  [1],
  [2],
  [3],
  [1,2],
  [1,3],
  [2,3],
  [1,2,3]
]
```

## 解题思路

### 方法一：DFS + 回溯（选或不选）
对于每个元素，我们都有两个选择：
1. 将该元素加入子集
2. 不将该元素加入子集

搜索树示意图：
```
                  []
        [1]                 []
   [1,2]    [1]        [2]     []
[1,2,3] [1,2] [1,3] [1] [2,3] [2] [3] []
```

### 方法二：DFS + 循环（按位置枚举）
从不同的起始位置开始，依次选择后面的元素：
1. 先确定子集的大小 k（从 0 到 n）
2. 对于每个大小 k，从不同起始位置选择 k 个元素

搜索树示意图：
```
                     []
         [1]         [2]         [3]
      [1,2]       [2,3]
   [1,2,3]
```

## 实现要点
1. **方法一（选或不选）**：
   - 对每个位置都进行选择/不选择的决策
   - 递归到数组末尾时收集结果
   - 需要回溯来撤销选择

2. **方法二（按位置枚举）**：
   - 从不同起始位置开始选择元素
   - 每次选择后都收集当前子集
   - 不需要显式的回溯操作

## 复杂度分析
- **时间复杂度**：O(2^n)
  - 每个元素都有选或不选两种可能
  - 总共有 2^n 个子集
- **空间复杂度**：O(n)
  - 递归调用栈的深度为 n
  - 不考虑存储答案所需的空间

## 注意事项
1. 空集也是一个有效的子集
2. 输入数组中的元素可以是任意顺序
3. 返回的子集可以是任意顺序
4. 如果输入数组有重复元素，需要先排序并跳过重复元素 