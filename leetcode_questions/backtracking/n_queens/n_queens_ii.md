# N 皇后 II

## 题目描述
给定一个整数 n，返回所有不同的 n 皇后问题的解决方案的数量。每一种解法包含一个不同的 n 皇后问题的棋子放置方案，该方案中 n 个皇后都不能互相攻击。

皇后可以攻击同一行、同一列或同一斜线上的棋子。

## 示例
输入: n = 4
输出: 2
解释: 4 皇后问题存在两个不同的解法。

```
解法 1:
[".Q..",  // 解法 1
 "...Q",
 "Q...",
 "..Q."]

解法 2:
["..Q.",  // 解法 2
 "Q...",
 "...Q",
 ".Q.."]
```

## 解题思路

### 回溯法
使用回溯法逐行放置皇后，通过三个集合记录已经被攻击的位置：
1. cols: 记录已被占用的列
2. hill_diagonals: 记录已被占用的右上到左下对角线 (row - col)
3. dale_diagonals: 记录已被占用的左上到右下对角线 (row + col)

#### 关键点
1. **对角线特征**
   - 右上到左下对角线：同一对角线上的点满足 row - col 相等
   - 左上到右下对角线：同一对角线上的点满足 row + col 相等

2. **回溯过程**
   - 逐行放置皇后
   - 对于每一行，尝试每一列的位置
   - 检查当前位置是否可以放置皇后
   - 放置皇后后继续递归
   - 回溯时移除当前位置的皇后

### 复杂度分析
- **时间复杂度**：O(n!)
  - 需要尝试所有可能的放置方案
  - 第一行有 n 种选择，第二行有 n-1 种选择，以此类推
- **空间复杂度**：O(n)
  - 需要三个集合来记录已被攻击的位置
  - 递归调用栈的深度为 n

## 代码实现要点
1. 使用集合来快速判断位置是否可用
2. 正确处理对角线的计算
3. 注意回溯时需要清理现场（移除记录）
4. 使用非局部变量 count 来累计解的数量 