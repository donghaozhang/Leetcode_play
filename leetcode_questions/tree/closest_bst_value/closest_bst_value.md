# BST中最接近的值

## 题目描述
给定一棵二叉搜索树（BST）和一个目标值，找到BST中最接近目标值的节点值。

## 示例
输入:
```
     5
   /   \
  3     7
 / \   / \
2   4 6   8
```
target = 3.7
输出: 4

## 解题思路

### 方法一：二分查找（推荐）
1. **核心思想**
   - 利用BST的性质进行二分查找
   - 每次比较当前节点值与目标值的差距
   - 根据大小关系选择搜索方向

2. **时间复杂度分析**
   - O(H)，H是树的高度
   - 平衡BST中为O(logN)
   - 最坏情况（链表）为O(N)

### 方法二：中序遍历
1. **核心思想**
   - 利用BST的中序遍历是升序序列的特性
   - 记录遍历过程中最接近的值
   - 当超过目标值时可以提前返回

2. **时间复杂度分析**
   - O(N)，N是节点总数
   - 需要遍历直到找到第一个大于目标值的节点
   - 无法利用BST的二分特性

### 实现细节
```python
# 二分查找方法
def find_closest_value(root, target):
    closest = root.val
    while root:
        if abs(root.val - target) < abs(closest - target):
            closest = root.val
        if target < root.val:
            root = root.left
        elif target > root.val:
            root = root.right
        else:
            return root.val
    return closest
```

## 复杂度分析
1. **二分查找方法**
   - 时间复杂度：O(H)
   - 空间复杂度：O(1)
   - 优点：高效，不需要遍历全树

2. **中序遍历方法**
   - 时间复杂度：O(N)
   - 空间复杂度：O(H)
   - 缺点：需要遍历更多节点

## 代码实现要点
1. 正确维护最接近值
2. 处理空树情况
3. 处理相等情况
4. 选择合适的遍历方向

## 常见错误
1. 未更新最接近值
2. 遍历方向错误
3. 未处理边界情况
4. 比较逻辑错误

## 优化策略
1. 使用迭代代替递归
2. 提前终止不必要的遍历
3. 优化比较逻辑
4. 处理特殊情况

## 相关题目
1. BST的搜索
2. BST的插入
3. BST的验证
4. BST的前驱后继 