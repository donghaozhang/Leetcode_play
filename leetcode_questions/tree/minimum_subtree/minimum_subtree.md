# 最小子树和

## 题目描述
给定一棵二叉树，找到和最小的子树。返回该子树的根节点。
子树和是子树中所有节点值的总和。

## 示例
输入:
```
     1
   /   \
  -5    2
 /  \  / \
1    2 4  3
```
输出: 节点-5
解释: 节点-5的子树（包含节点-5、1、2）的和为-2，是所有子树中最小的。

## 解题思路

### DFS后序遍历
1. **核心思想**
   - 使用后序遍历计算每个子树的和
   - 同时维护全局最小和
   - 返回子树和供父节点使用

2. **状态定义**
   - sum: 子树节点值之和
   - min_sum: 当前找到的最小和
   - result: 最小和子树的根节点

### 实现细节
```python
def get_subtree_sum(node):
    if not node:
        return 0
        
    left_sum = get_subtree_sum(node.left)
    right_sum = get_subtree_sum(node.right)
    
    curr_sum = left_sum + right_sum + node.val
    if curr_sum < min_sum:
        min_sum = curr_sum
        result = node
        
    return curr_sum
```

## 复杂度分析
- 时间复杂度：O(N)，每个节点只访问一次
- 空间复杂度：O(H)，H是树的高度，递归栈的深度

## 代码实现要点
1. 正确计算子树和
2. 维护全局最小和
3. 处理空节点情况
4. 处理负值节点

## 常见错误
1. 计算子树和错误
2. 未考虑负值节点
3. 未正确更新全局最小值
4. 返回值处理错误

## 优化策略
1. 使用元组返回多个值
2. 及早判断空节点
3. 使用nonlocal访问外部变量
4. 避免重复计算

## 相关题目
1. 二叉树的最大路径和
2. 平衡二叉树
3. 最大平均值子树
4. 二叉树中的最大路径和 