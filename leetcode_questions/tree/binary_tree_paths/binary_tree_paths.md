# 二叉树的所有路径

## 题目描述
给定一个二叉树，返回所有从根节点到叶子节点的路径。
路径用字符串表示，路径中的节点值用 "->" 连接。

## 示例
输入:
```
   1
 /   \
2     3
 \
  5
```
输出: ["1->2->5", "1->3"]

## 回溯判断标准

### 需要手动回溯的情况
1. **修改了当前状态**
   - 在递归过程中修改了数组、路径等
   - 例如：path.append() 后需要 path.pop()

2. **状态需要共享**
   - 多个递归分支共享同一个状态变量
   - 例如：共享的路径列表、访问标记数组

3. **需要恢复现场**
   - 递归返回时需要恢复到之前的状态
   - 确保不影响其他分支的遍历

### 不需要手动回溯的情况
1. **参数传递**
   - 通过参数传递新的状态
   - 例如：path + [node.val]

2. **局部变量**
   - 每次递归都创建新的变量
   - 变量的生命周期限于当前递归

3. **不可变对象**
   - 使用字符串、元组等不可变对象
   - 每次操作都会创建新对象

## 解题思路

### DFS + 回溯
1. **状态定义**
   - path：当前路径
   - paths：存储所有路径

2. **递归过程**
   - 将当前节点加入路径
   - 到达叶子节点时保存路径
   - 递归处理左右子树
   - 回溯移除当前节点

### 实现细节
```python
def dfs(node, path, paths):
    if not node:
        return
        
    path.append(str(node.val))  # 修改状态
    
    if not node.left and not node.right:
        paths.append('->'.join(path))
    else:
        dfs(node.left, path, paths)
        dfs(node.right, path, paths)
        
    path.pop()  # 手动回溯
```

## 复杂度分析
- 时间复杂度：O(N)，N是节点数
- 空间复杂度：O(H)，H是树的高度

## 代码实现要点
1. 正确处理空节点
2. 路径的添加和回溯
3. 叶子节点的判断
4. 路径的字符串表示

## 常见错误
1. 忘记回溯
2. 路径格式错误
3. 叶子节点判断错误
4. 未处理空树

## 相关题目
1. 二叉树的路径和
2. 二叉树的最大路径和
3. 路径总和系列
4. 二叉树的直径 