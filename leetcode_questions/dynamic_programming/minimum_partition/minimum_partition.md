# 最小划分

## 题目描述
给定一个数组，将其划分为两个子集，使得两个子集的和的差最小。
返回两个子集和的最小差值。

## 示例
输入: [1, 6, 11, 5]
输出: 1
解释: 
- 第一组：[1, 5, 6]，和为12
- 第二组：[11]，和为11
- 差值为|12-11| = 1

## 解题思路

### 转化为背包问题
这个问题可以转化为01背包问题：

1. **问题转化**
   - 总和为sum，如果能找到一个子集和最接近sum/2
   - 那么这个划分就是最优的
   - 变成了：找最接近sum/2的子集和

2. **动态规划解法**
   - dp[j] 表示是否能组成和为j的子集
   - 对每个数字，更新可能的和
   - 记录最大的可行和max_sum
   - 最终差值为 |sum - 2*max_sum|

### 状态转移
```
dp[j] = dp[j] || dp[j-num]  (从大到小遍历j)
```
- dp[j]：不选当前数字
- dp[j-num]：选当前数字

### 为什么这样是正确的？
1. **最优性**
   - 如果一个子集和最接近sum/2
   - 那么两个子集的差一定最小

2. **可行性**
   - 使用01背包的思路保证每个数字只用一次
   - 从大到小遍历避免重复使用

### 复杂度分析
- 时间复杂度：O(n*sum)
  - n是数组长度
  - sum是数组总和
- 空间复杂度：O(sum)
  - 使用一维dp数组
  - sum是数组总和的一半

## 代码实现要点
1. 正确计算目标和（sum/2）
2. 从大到小遍历避免重复使用数字
3. 记录最大可行和
4. 处理边界情况（空数组等）
5. 正确计算最终差值 