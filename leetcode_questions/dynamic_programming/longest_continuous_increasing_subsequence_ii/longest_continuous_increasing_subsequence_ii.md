# 最长连续递增子序列 II

## 题目描述
给定一个二维整数矩阵，找到一条最长的连续递增路径。每次可以向上、下、左、右四个方向移动，要求路径上的数字严格递增。

## 示例
输入:
```
[
  [1, 2, 3],
  [4, 5, 6],
  [7, 8, 9]
]
```
输出: 9
解释: 路径 1->2->3->4->5->6->7->8->9 是最长的连续递增路径。

## 解题思路

### 动态规划 + 记忆化搜索
这是一个二维动态规划问题，可以使用记忆化搜索来优化：

1. **状态定义**
   - dp[i][j] 表示以位置(i,j)结尾的最长连续递增子序列长度
   - 每个位置可以从四个方向的较小值转移而来

2. **状态转移**
   ```
   dp[i][j] = max{dp[ni][nj] + 1}
   其中 (ni,nj) 是(i,j)四个相邻位置中满足 matrix[ni][nj] < matrix[i][j] 的位置
   ```

3. **实现方式**
   - 使用记忆化搜索避免重复计算
   - 从每个位置开始搜索，记录最大值
   - 使用DFS遍历所有可能的路径

### 为什么使用记忆化搜索？
- 路径可以是任意方向的
- 普通动态规划难以确定计算顺序
- 记忆化搜索可以自动处理依赖关系

### 复杂度分析
- 时间复杂度：O(m*n)
  - 每个位置最多被计算一次
  - 每个位置的计算是O(1)
- 空间复杂度：O(m*n)
  - 需要dp数组存储中间结果
  - 递归调用栈的深度最大为O(m*n)

## 代码实现要点
1. 正确处理四个方向的移动
2. 使用记忆化数组避免重复计算
3. 处理边界条件（矩阵为空等）
4. 注意路径必须严格递增 