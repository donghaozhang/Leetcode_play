# 跳跃游戏

## 题目描述
给定一个非负整数数组，你最初位于数组的第一个位置。数组中的每个元素代表你在该位置可以跳跃的最大长度。判断你是否能够到达最后一个位置。

## 示例
输入: [2,3,1,1,4]
输出: true
解释: 从位置 0 跳到位置 1，然后跳到最后一个位置。

## 解题思路

### 贪心算法
使用贪心策略，维护当前能到达的最远位置：

1. **核心思想**
   - 记录当前能到达的最远位置 max_reach
   - 遍历每个位置时更新 max_reach
   - 如果某个位置无法到达，则无法到达终点

2. **实现步骤**
   - 初始化 max_reach = 0
   - 遍历数组中的每个位置 i：
     - 如果 i > max_reach，说明当前位置无法到达
     - 更新 max_reach = max(max_reach, i + nums[i])
     - 如果 max_reach >= n-1，说明可以到达终点

### 为什么这样是正确的？
1. **可达性**
   - 如果位置 i 可达，那么 [i, i+nums[i]] 范围内的所有位置都可达
   - max_reach 记录了所有可达位置的最大值

2. **最优性**
   - 不需要考虑具体的跳跃路径
   - 只要知道能否到达即可
   - 贪心策略保证了正确性

### 复杂度分析
- 时间复杂度：O(n)
  - 只需要遍历一次数组
- 空间复杂度：O(1)
  - 只需要常数额外空间

## 代码实现要点
1. 正确维护最远可达位置
2. 处理边界情况（空数组、单个元素）
3. 提前返回优化（当已经可以到达终点时）
4. 注意遍历范围（可以只遍历到倒数第二个位置）
5. 最后需要判断是否能到达终点 