# 01背包问题

## 题目描述
给定 n 个物品和一个大小为 m 的背包，每个物品的大小为 A[i]。问最多能装多满？
每个物品只能使用一次（这就是01背包名称的由来）。

## 示例
输入: m = 10, A = [3, 4, 8, 5]
输出: 9
解释: 装入 3 + 4 + 2 = 9，不能装入更多。

## 解题思路

### 动态规划基础解法
使用二维动态规划数组：

1. **状态定义**
   - dp[i][j] 表示前i个物品能否组成大小j
   - boolean类型，true表示可以组成，false表示不能

2. **状态转移**
   ```
   dp[i][j] = dp[i-1][j] || dp[i-1][j-A[i-1]]  (if j >= A[i-1])
   ```
   - dp[i-1][j]：不选第i个物品
   - dp[i-1][j-A[i-1]]：选第i个物品

3. **初始化**
   - dp[0][0] = true
   - dp[i][0] = true（不选任何物品可以组成大小0）

### 空间优化
使用滚动数组（一维数组）优化空间：

1. **状态压缩**
   - 只使用一维数组 dp[j]
   - 从大到小遍历避免重复使用物品

2. **优化后的转移**
   ```
   dp[j] |= dp[j - item]  (从大到小遍历j)
   ```

### 为什么要从大到小遍历？
- 避免一个物品被多次使用
- 保证每个物品最多被使用一次
- 维持01背包的约束条件

### 复杂度分析
- **基础解法**
  - 时间复杂度：O(n*m)
  - 空间复杂度：O(n*m)
- **优化解法**
  - 时间复杂度：O(n*m)
  - 空间复杂度：O(m)

## 代码实现要点
1. 正确初始化dp数组
2. 注意遍历顺序（优化版本需要从大到小）
3. 处理边界情况（空数组，背包大小为0等）
4. 最后需要从大到小找到最大可行值 