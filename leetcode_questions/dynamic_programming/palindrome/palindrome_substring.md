# 最长回文子串问题解析

## 问题描述
给定一个字符串 s，找到 s 中最长的回文子串。

## 示例
输入: "babad"
输出: "bab" 或 "aba"

输入: "cbbd"
输出: "bb"

## 解题思路

### 区间型动态规划介绍
区间型动态规划（Interval DP）是动态规划的一种特殊类型，主要用于解决区间上的问题。其特点如下：

1. **状态定义特点**
   - 通常状态定义为 `dp[i][j]`，表示区间 `[i,j]` 上的某个性质或最优解
   - i 是区间起点，j 是区间终点
   - 大区间的解依赖于小区间的解

2. **计算顺序特点**
   ```python
   for length in range(2, n + 1):           # 枚举区间长度
       for i in range(n - length + 1):      # 枚举起点
           j = i + length - 1               # 计算终点
           # 计算 dp[i][j]
   ```

3. **常见应用场景**
   - 回文串相关问题
   - 区间合并问题
   - 矩阵链乘法
   - 石子合并问题

### 动态规划方法 (时间复杂度 O(n²))

1. **状态定义**
   - `dp[i][j]` 表示字符串s从索引i到j的子串是否为回文串
   - i, j 分别表示子串的起始和结束位置

2. **状态转移方程**
   - 当 s[i] == s[j] 时：
     - 如果子串长度 ≤ 3，则 dp[i][j] = true
     - 如果子串长度 > 3，则 dp[i][j] = dp[i+1][j-1]
   - 当 s[i] != s[j] 时：
     - dp[i][j] = false

3. **边界条件**
   - 单个字符是回文串：dp[i][i] = true
   - 空串是回文串

4. **计算顺序**
   - 由于状态依赖于子问题dp[i+1][j-1]的结果
   - 需要按照子串长度从小到大计算
   - 对于每个长度，遍历所有可能的起始位置

### 实现要点
- 从小区间开始计算，逐步扩大到大区间
- 大区间的结果依赖于小区间的结果
- 需要合理安排计算顺序，确保计算大区间时小区间的值已经计算出来
- 注意维护最长回文子串的起始位置和长度

## 复杂度分析
- 时间复杂度：O(n²)
  - 需要填充 n×n 的动态规划表
  - 每个状态的计算是 O(1) 的
- 空间复杂度：O(n²)
  - 需要 n×n 的二维数组存储状态 