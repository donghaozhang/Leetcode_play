# 搜索二维矩阵 II

## 题目描述
给定一个二维矩阵，其中：
- 每一行都按照从左到右递增的顺序排序
- 每一列都按照从上到下递增的顺序排序

编写一个高效的算法来搜索矩阵中的一个目标值。

## 示例
输入:
```
matrix = [
  [1,   4,  7, 11, 15],
  [2,   5,  8, 12, 19],
  [3,   6,  9, 16, 22],
  [10, 13, 14, 17, 24],
  [18, 21, 23, 26, 30]
]
target = 5
```
输出: true

## 解题思路

### 方法：从右上角搜索
从矩阵的右上角开始搜索，利用矩阵的有序性质可以在每一步排除一行或一列：

1. **初始位置**
   - 从右上角 (row=0, col=n-1) 开始
   - 这个位置的特点是：向左都比它小，向下都比它大

2. **搜索过程**
   - 如果当前值等于目标值，返回 true
   - 如果当前值大于目标值，说明这一列都太大，col--
   - 如果当前值小于目标值，说明这一行都太小，row++

3. **终止条件**
   - row 超出矩阵范围或 col 小于 0 时结束
   - 找到目标值时提前返回

### 为什么选择右上角？
- 右上角元素具有特殊性质：它是其所在行的最大值，所在列的最小值
- 这样在比较时可以有效排除行或列
- 左上角或右下角不具备这个性质，无法有效缩小搜索范围

### 复杂度分析
- 时间复杂度：O(m + n)，其中 m 和 n 分别是矩阵的行数和列数
- 空间复杂度：O(1)

## 代码实现要点
1. 处理空矩阵的边界情况
2. 正确移动搜索指针
3. 注意不要超出矩阵范围 

## 算法说唱
```
矩阵排序有玄机，行列递增是关键
右上角起步最精妙，左小右大有规律

比目标大向左移，排除整列不犹豫
比目标小向下走，排除整行不回头

线性复杂度最高效，大O(m+n)不简单
右上角搜索有妙招，复杂问题我来解
``` 