# 搜索二维矩阵

## 题目描述
给定一个 m x n 的有序矩阵，该矩阵具有以下特性：
1. 每行中的整数从左到右按升序排列
2. 每行的第一个整数大于前一行的最后一个整数

编写一个高效的算法来判断矩阵中是否存在一个目标值。

## 示例
输入:
```
matrix = [
  [1,   3,  5,  7],
  [10, 11, 16, 20],
  [23, 30, 34, 50]
]
target = 3
```
输出: true

## 解题思路

### 二分查找法
由于矩阵的特殊性质，我们可以将其视为一个有序数组来进行二分查找：

1. **转换思路**
   - m × n 的矩阵可以看作长度为 m*n 的有序数组
   - 对于位置 mid，可以通过以下方式转换为矩阵坐标：
     - 行号 = mid // n（n为列数）
     - 列号 = mid % n

2. **算法步骤**
   - 初始化左右指针：left = 0, right = m*n - 1
   - 当 left <= right 时进行二分查找：
     - 计算中间位置 mid = (left + right) // 2
     - 将 mid 转换为矩阵中的行列坐标
     - 比较矩阵中该位置的值与目标值
     - 根据比较结果调整左右指针

### 复杂度分析
- 时间复杂度：O(log(m*n))
- 空间复杂度：O(1)

## 代码实现要点
1. 注意处理空矩阵的边界情况
2. 正确计算行列索引
3. 使用整数除法和取模运算进行坐标转换 

## 算法说唱
```
二维矩阵有序排，特性助我寻目标
二分查找是法宝，一维转换是关键

左右指针框边界，中值计算比大小
行用mid除列数，列用mid求余数

相等返真不相等，指针调整再循环
空矩阵要判断，log(mn)效率高

分而治之有妙招，复杂问题简单解
``` 