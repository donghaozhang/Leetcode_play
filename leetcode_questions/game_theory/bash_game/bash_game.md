# Bash 游戏问题解析

## 问题描述
你正在和朋友玩一个游戏：桌子上有一堆石头，每次你们都可以从中拿走 1 到 3 颗石头。拿走最后一颗石头的人获胜。你是先手。

给定石头的数量 n，判断你是否能赢得比赛。假设两个人都采用最优策略。

例如：
```
输入: n = 4
输出: false
解释: 
如果你拿走 1 颗石头，对方可以拿走 3 颗石头
如果你拿走 2 颗石头，对方可以拿走 2 颗石头
如果你拿走 3 颗石头，对方可以拿走 1 颗石头
在所有情况下，对方都可以拿走最后一颗石头赢得游戏
```

## 解题思路

### 方法一：记忆化搜索（自顶向下的动态规划）
1. **状态定义**  
   `dp[i]` 表示还剩 i 颗石头时，当前玩家是否能赢。

2. **状态转移**  
   ```
   dp[i] = !(dp[i-1] && dp[i-2] && dp[i-3])
   ```
   解释：当前玩家要赢，需要存在至少一种拿法，使得对手在剩余状态下必输。

3. **边界条件**  
   - dp[0] = false（没有石头可拿，当前玩家输）
   - dp[1] = true（可以直接拿走赢得游戏）
   - dp[2] = true（可以直接拿走赢得游戏）
   - dp[3] = true（可以直接拿走赢得游戏）

### 方法二：数学归纳（找规律）
通过分析可以发现一个规律：
- 当 n % 4 == 0 时，先手必输
- 其他情况下，先手必胜

这是因为：
1. 如果 n 是 4 的倍数，无论先手如何选择（1、2 或 3），后手总能使剩余石头数保持 4 的倍数
2. 最终先手面对 4 颗石头时必输（如问题示例所述）

## 复杂度分析
### 方法一：记忆化搜索
- **时间复杂度**：O(n)
  - 每个状态只需计算一次
- **空间复杂度**：O(n)
  - 需要一个长度为 n 的数组存储状态

### 方法二：数学归纳
- **时间复杂度**：O(1)
- **空间复杂度**：O(1)

## 代码实现比较
两种方法各有优势：
- 记忆化搜索方法更通用，易于扩展（比如改变可拿石头的数量范围）
- 数学归纳方法更高效，但不易扩展 