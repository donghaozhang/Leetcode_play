# 单词阶梯问题解析

## 问题描述
给定两个单词（`beginWord` 和 `endWord`）和一个字典，找出从 `beginWord` 到 `endWord` 的最短转换序列的长度。转换需遵循如下规则：
1. 每次转换只能改变一个字母
2. 转换过程中的中间单词必须在字典中出现

例如：
```
输入:
beginWord = "hit"
endWord = "cog"
wordList = ["hot","dot","dog","lot","log","cog"]

输出: 5
解释: 一个最短转换序列是 "hit" -> "hot" -> "dot" -> "dog" -> "cog"
返回它的长度 5
```

## 解题思路

### 方法：广度优先搜索（BFS）
将每个单词看作图中的一个节点，如果两个单词可以通过改变一个字母相互转换，则这两个节点之间有一条边。

1. **预处理**
   - 将 wordList 转换为集合，便于快速查找
   - 检查 endWord 是否在字典中，如果不在则无法转换

2. **BFS 实现步骤**
   - 使用队列存储当前层的所有单词
   - 使用集合记录已访问的单词
   - 对于当前单词的每个位置，尝试替换为 a-z 的每个字母
   - 如果新单词在字典中且未访问过，则加入队列

3. **优化技巧**
   - 可以同时从起点和终点开始搜索（双向 BFS）
   - 当找到一个单词同时出现在两个方向的搜索中时，就找到了最短路径

## 复杂度分析
- **时间复杂度**：O(N×26×L)
  - N 是单词的长度
  - 26 是字母表中字母的数量
  - L 是字典中单词的数量
- **空间复杂度**：O(L)
  - 需要存储访问过的单词
  - 队列中最多存储 L 个单词

## 实现要点
1. 使用 BFS 而不是 DFS，因为要找最短路径
2. 使用集合存储字典和已访问单词，提高查找效率
3. 注意处理特殊情况（如 endWord 不在字典中）
4. 可以通过双向 BFS 优化搜索效率 