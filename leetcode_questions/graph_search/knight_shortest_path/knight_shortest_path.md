# 骑士最短路径问题解析

## 问题描述
在一个棋盘上，给定骑士（马）的起始位置和目标位置，求骑士到达目标位置的最少步数。骑士按照国际象棋中马的走法移动：
- 可以走 8 个方向
- 每次移动是 "L" 形状：横向走 2 格，纵向走 1 格；或纵向走 2 格，横向走 1 格

例如：
```
输入:
source = [0, 0]
destination = [2, 1]
输出: 2
解释:
[0,0] -> [2,1]
骑士可以按照如下路径到达终点：
1. [0,0] -> [1,2] -> [2,1]
2. [0,0] -> [-1,2] -> [2,1]
```

## 解题思路

### 方法：广度优先搜索（BFS）
使用 BFS 可以保证找到的第一条路径就是最短路径。

1. **移动方向**  
   骑士可以移动的 8 个方向用坐标差表示：
   ```python
   DIRECTIONS = [
       (-2, -1), (-2, 1), (2, -1), (2, 1),
       (-1, -2), (-1, 2), (1, -2), (1, 2)
   ]
   ```

2. **BFS 实现步骤**
   - 使用队列存储待访问的位置
   - 使用集合记录已访问的位置，避免重复访问
   - 按层遍历，每一层代表移动的步数
   - 当找到目标位置时返回当前步数

3. **位置合法性检查**
   - 确保新位置在棋盘范围内
   - 确保新位置未被访问过

## 复杂度分析
- **时间复杂度**：O(N×M)
  - N、M 为棋盘的长和宽
  - 最坏情况下需要访问所有格子
- **空间复杂度**：O(N×M)
  - 需要队列和访问集合来存储位置
  - 最坏情况下可能需要存储所有格子

## 实现要点
1. 使用 BFS 而不是 DFS，因为要求最短路径
2. 使用方向数组来简化 8 个可能移动方向的处理
3. 注意边界条件和位置合法性的检查
4. 使用访问集合避免重复访问同一位置 