# 快速幂算法

## 问题描述
实现 pow(x, n) ，即计算 x 的 n 次幂函数。

### 示例
```
输入: x = 2.00000, n = 10
输出: 1024.00000

输入: x = 2.00000, n = -2
输出: 0.25000
解释: 2^(-2) = (1/2)^2 = 1/4 = 0.25
```

## 算法原理

快速幂算法是一种高效计算乘方的算法，其核心思想是将指数按二进制拆分，从而将时间复杂度从 O(n) 降低到 O(log n)。

### 递归实现原理
1. 对于任意整数n，可以将其分解为：n = n/2 + n/2（偶数）或 n = n/2 + n/2 + 1（奇数）
2. 因此 x^n 可以分解为：
   - 偶数：x^n = x^(n/2) * x^(n/2)
   - 奇数：x^n = x^(n/2) * x^(n/2) * x

### 迭代实现原理
1. 将指数n转换为二进制表示
2. 根据二进制位的1和0来决定是否将当前的x累乘到结果中
3. 每一步将x自乘，对应二进制位的权重

例如，计算 x^11：
- 11的二进制是1011
- x^11 = x^8 * x^2 * x^1
- 对应二进制的每一位1

## 代码实现要点

### 递归版本
```python
def fast_power(x, n):
    if n == 0:
        return 1
    half = fast_power(x, n // 2)
    if n % 2 == 0:
        return half * half
    return half * half * x
```

### 迭代版本
```python
def fast_power_iterative(x, n):
    result = 1
    current_product = x
    while n > 0:
        if n & 1:  # 当前位是1
            result *= current_product
        current_product *= current_product
        n >>= 1
    return result
```

## 复杂度分析

- **时间复杂度**: O(log n)
  - 每次将指数除以2，直到为0
  - 二进制表示的位数就是循环的次数

- **空间复杂度**: 
  - 递归版本：O(log n)，递归调用栈的深度
  - 迭代版本：O(1)，只需要常数空间

## 注意事项

1. **处理负数指数**：
   - 需要将x转换为1/x
   - 将n转换为-n

2. **处理边界情况**：
   - n = 0 时返回1
   - x = 0 且 n < 0 时需要特殊处理

3. **浮点数精度**：
   - 在比较浮点数结果时要考虑精度误差
   - 可以使用abs(a - b) < 1e-10来比较

## 应用场景

1. 大数幂模运算（密码学）
2. 矩阵快速幂
3. 递推关系的快速计算
4. 计算斐波那契数列的第n项 