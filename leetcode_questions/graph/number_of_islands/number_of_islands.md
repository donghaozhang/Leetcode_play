# 岛屿数量

## 题目描述
给定一个由 '1'（陆地）和 '0'（水）组成的二维网格，计算岛屿的数量。
一个岛屿是由相邻的陆地单元组成的区域，这里的相邻指水平或垂直方向相邻。
可以假设网格的四个边均被水包围。

## 示例
输入:
```
[
  [1, 1, 0, 0, 0],
  [1, 1, 0, 0, 0],
  [0, 0, 1, 0, 0],
  [0, 0, 0, 1, 1]
]
```
输出: 3

## 解题思路

### DFS标记法
1. **核心思想**
   - 遍历网格寻找陆地
   - 使用DFS标记连通的陆地
   - 计数发现的新岛屿

2. **实现细节**
```python
def dfs(row, col):
    if (row < 0 or row >= rows or 
        col < 0 or col >= cols or 
        grid[row][col] != 1):
        return
        
    grid[row][col] = 2  # 标记已访问
    
    # 访问四个方向
    dfs(row + 1, col)
    dfs(row - 1, col)
    dfs(row, col + 1)
    dfs(row, col - 1)
```

## 复杂度分析
- 时间复杂度：O(M × N)，其中M和N是网格的行数和列数
- 空间复杂度：O(M × N)，最坏情况下的递归栈深度

### 复杂度分析详解
1. **时间复杂度**
   - 需要遍历整个网格：O(M × N)
   - 每个陆地单元最多被访问一次
   - DFS的总时间与陆地单元数成正比

2. **空间复杂度**
   - 递归栈的最大深度：O(M × N)
   - 最坏情况是整个网格都是陆地
   - 可以通过迭代方法优化空间使用

## 代码实现要点
1. 正确处理边界条件
2. 标记已访问的陆地
3. 遍历四个方向
4. 维护岛屿计数

## 常见错误
1. 边界检查不完整
2. 未标记已访问节点
3. 方向遍历不完整
4. 计数逻辑错误

## 优化策略
1. 使用迭代代替递归
2. 原地修改避免额外空间
3. 方向数组简化代码
4. 并查集解法

## 相关题目
1. 最大岛屿面积
2. 岛屿的周长
3. 封闭岛屿的数量
4. 飞地的数量 