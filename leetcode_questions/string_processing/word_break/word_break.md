# 单词划分问题解析

## 问题描述
给定一个非空字符串 `s` 和一个包含非空单词的字典 `wordDict`，判断 `s` 是否可以被拆分成一个或多个出现在 `wordDict` 中的单词。

例如：
- 输入: `s = "lintcode"`, `wordDict = {"lint", "code", "li"}`  
  输出: `true`  
  解释: 可以拆分为 `"lint" + "code"`。
- 输入: `s = "lintcode"`, `wordDict = {"lin", "code", "li"}`  
  输出: `false`  
  解释: 无法以任何方式拆分使得每个单词都出现在字典中。

## 解题思路

### 动态规划方法

1. **状态定义**  
   定义一维数组 `dp`，其中 `dp[i]` 表示字符串 `s[0:i]` 是否可以被拆分成一个或多个字典中的单词。

2. **初始条件**  
   空字符串被认为可以正确拆分，所以 `dp[0] = True`。

3. **状态转移方程**  
   对于每个位置 `i`（从 `1` 到 `len(s)`），遍历所有可能的分割点 `j` (从 `0` 到 `i-1`)：
   - 如果 `dp[j]` 为 `True` 且子串 `s[j:i]` 在 `wordDict` 中，则说明 `s[0:i]` 可以拆分，将 `dp[i]` 设为 `True` 并终止内层循环。

   公式描述：
   ```
   dp[i] = True, if ∃j (0 ≤ j < i) 使得 dp[j] == True 且 s[j:i] ∈ wordDict
   ```

4. **返回结果**  
   最终返回 `dp[len(s)]` 的布尔值。

### 时间和空间复杂度
- **时间复杂度：** O(n²)  
  n 为字符串的长度，最坏情况下需要检查所有子串。
- **空间复杂度：** O(n)  
  用于保存 dp 数组。

## 示例说明
- 对于 `s = "lintcode"` 和 `wordDict = {"lint", "code", "li"}`：
  - `dp[0] = True`  
  - 当 `i = 4` 时，`s[0:4] = "lint"` 在字典中，因此 `dp[4] = True`。
  - 当 `i = 8` 时，检查 `s[4:8] = "code"`，且 `dp[4] = True`，故 `dp[8] = True`。
  - 返回结果为 `True`。

- 对于 `s = "lintcode"` 和 `wordDict = {"lin", "code", "li"}`：
  - 虽然 `s[0:3] = "lin"` 在字典中（`dp[3] = True`），但剩下的 `"tcode"` 无法在字典中找到对应拆分，最终 `dp[8] = False`。

## 总结
利用动态规划构建 dp 数组，依次检查每个位置是否能构成一个合法拆分，即可高效解决单词划分问题。 