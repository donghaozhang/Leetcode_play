# 旅行商问题 (TSP)

## 题目描述
给定n个城市和城市之间的距离矩阵，求从起点出发，访问每个城市恰好一次并返回起点的最短路径长度。

## 示例
输入:
n = 4
distances = [
    [0, 1, 2, 3],
    [1, 0, 4, 5],
    [2, 4, 0, 6],
    [3, 5, 6, 0]
]
输出: 11
解释: 最短路径为 0 -> 1 -> 2 -> 3 -> 0

## 解题思路

### 方法一：状态压缩动态规划（递归）
1. **核心思想**
   - 使用位运算表示访问状态
   - 递归搜索所有可能路径
   - 记忆化避免重复计算

2. **状态表示**
   - state: 已访问城市的集合（位表示）
   - current: 当前所在城市
   - dp[state][current]: 最短路径长度

3. **状态转移**
   - 遍历未访问的城市
   - 更新最短路径
   - 递归处理剩余城市

### 方法二：状态压缩动态规划（迭代）
1. **核心思想**
   - 按状态大小顺序遍历
   - 动态构建最优解
   - 避免递归开销

2. **实现细节**
   - 初始化边界状态
   - 按顺序扩展状态
   - 维护最优解

### 复杂度分析
- 时间复杂度：O(n^2 * 2^n)
  - 状态数：O(n * 2^n)
  - 每个状态转移：O(n)
- 空间复杂度：O(n * 2^n)
  - dp数组大小

## 优化策略
1. **位运算优化**
   - 使用位操作代替集合
   - 快速状态检查和更新
   - 减少内存使用

2. **剪枝优化**
   - 利用三角不等式
   - 提前终止无效路径
   - 优先选择近邻城市

3. **启发式搜索**
   - 贪心选择下一个城市
   - 使用最近邻算法
   - 局部搜索优化

## 应用场景
1. 物流配送路线规划
2. 电路板钻孔优化
3. 网络布线优化
4. 机器人路径规划

## 代码实现要点
1. 正确处理位运算
2. 高效状态转移
3. 处理边界情况
4. 优化空间使用

## 常见错误
1. 状态表示错误
2. 遗漏返回起点
3. 位运算错误
4. 内存溢出

## 扩展思考
1. **近似算法**
   - 贪心算法
   - 2-opt优化
   - 遗传算法
   - 蚁群算法

2. **问题变种**
   - 多旅行商问题
   - 带时间窗的TSP
   - 带容量限制的TSP
   - 非对称TSP 