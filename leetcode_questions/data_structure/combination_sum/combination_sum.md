# 组合总和

## 题目描述
给定一个无重复元素的正整数数组 candidates 和一个正整数 target，找出 candidates 中所有可以使数字和为目标数 target 的组合。
candidates 中的数字可以无限制重复被选取。

## 示例
输入: candidates = [2, 3, 6, 7], target = 7
输出: [[2, 2, 3], [7]]

## 与 Subsets 的区别

### 1. 目标不同
- **Subsets**：找出所有可能的子集
- **Combination Sum**：找出和为目标值的组合

### 2. 元素使用
- **Subsets**：每个元素最多使用一次
- **Combination Sum**：每个元素可以重复使用

### 3. 剪枝策略
- **Subsets**：不需要剪枝
- **Combination Sum**：可以通过目标和剪枝

## 解题思路

### 方法一：回溯法
1. **核心思想**
   - 使用回溯法生成所有可能的组合
   - 通过目标和进行剪枝
   - 允许重复使用元素

2. **实现细节**
   - 排序数组以便剪枝
   - 记录当前和与目标和的差值
   - 维护当前组合

3. **剪枝策略**
   - 如果当前数字大于剩余和，停止搜索
   - 从当前位置开始搜索（允许重复使用）
   - 保持组合有序避免重复

### 方法二：动态规划
1. **核心思想**
   - 对每个可能的和计算所有组合
   - 通过已知组合构建新组合
   - 维护组合的有序性

2. **实现细节**
   - dp[i]表示和为i的所有组合
   - 通过添加新数字构建组合
   - 确保组合非递减避免重复

### 复杂度分析
- 时间复杂度：O(n^(target/min))
  - n是候选数字数量
  - min是最小候选数字
- 空间复杂度：O(target)
  - 递归深度或DP数组大小

## 代码实现要点
1. 正确处理重复使用
2. 高效剪枝
3. 维护组合顺序
4. 避免重复组合

## 优化可能
1. 使用二分查找优化剪枝
2. 预处理优化数字选择
3. 并行生成组合
4. 使用迭代器减少内存使用

## 应用场景
1. 找零问题
2. 资源分配
3. 背包问题变种
4. 路径规划

## 常见错误
1. 生成重复组合
2. 漏掉可能的组合
3. 剪枝条件不当
4. 内存使用过多 