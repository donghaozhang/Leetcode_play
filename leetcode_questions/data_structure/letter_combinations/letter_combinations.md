# 电话号码的字母组合

## 题目描述
给定一个仅包含数字 2-9 的字符串，返回所有它能表示的字母组合。数字到字母的映射与电话按键相同。

## 示例
输入: "23"
输出: ["ad", "ae", "af", "bd", "be", "bf", "cd", "ce", "cf"]

## 图论基本概念

### 1. 点（顶点）
- 图中的基本元素
- 在本题中：每个数字对应的每个字母是一个点
- 例如：数字2对应的点有 'a', 'b', 'c'

### 2. 边（连接）
- 连接两个点的线
- 在本题中：相邻数字的字母之间可以形成边
- 例如：'a'(2) 可以连接到 'd','e','f'(3)

### 3. 路径
- 从起点到终点经过的边的序列
- 在本题中：一个有效的字母组合就是一条路径
- 例如："ad" 是一条从 'a' 到 'd' 的路径

## 解题思路

### 回溯法（DFS）
1. **核心思想**
   - 每个数字看作一层
   - 每层选择当前数字对应的一个字母
   - 形成一条从第一层到最后一层的路径

2. **实现步骤**
   ```python
   # 数字到字母的映射
   DIGIT_TO_LETTERS = {
       '2': 'abc', '3': 'def',
       '4': 'ghi', '5': 'jkl', '6': 'mno',
       '7': 'pqrs', '8': 'tuv', '9': 'wxyz'
   }
   
   def backtrack(index, path):
       if len(path) == len(digits):
           result.append(''.join(path))
           return
           
       for letter in DIGIT_TO_LETTERS[digits[index]]:
           path.append(letter)
           backtrack(index + 1, path)
           path.pop()
   ```

### 复杂度分析
- 时间复杂度：O(4^n)，其中n是数字个数
- 空间复杂度：O(n)，递归深度

## 代码实现要点
1. 建立数字到字母的映射
2. 正确处理递归和回溯
3. 维护当前路径
4. 处理边界情况

## 图论应用
1. **DFS vs BFS**
   - DFS：适合生成所有可能的组合
   - BFS：适合找最短路径（本题不适用）

2. **路径特点**
   - 长度固定（等于数字个数）
   - 不能重复访问同一层
   - 必须访问所有层

## 常见错误
1. 映射表不完整
2. 递归终止条件错误
3. 路径管理不当
4. 未处理空字符串

## 相关题目
1. 组合总和
2. 全排列
3. 子集
4. 单词搜索 