# 全排列

## 题目描述
给定一个没有重复数字的序列，返回其所有可能的全排列。

## 示例
输入: [1,2,3]
输出:
[
  [1,2,3],
  [1,3,2],
  [2,1,3],
  [2,3,1],
  [3,1,2],
  [3,2,1]
]

## 解题思路

### 方法一：回溯法
1. **核心思想**
   - 使用回溯法生成所有排列
   - 使用集合记录已使用的数字
   - 递归构建排列

2. **实现细节**
   - 维护已使用数字集合
   - 递归生成剩余数字的排列
   - 回溯撤销选择

3. **剪枝策略**
   - 已使用的数字不再选择
   - 排列长度达到目标时返回

### 方法二：迭代法
1. **核心思想**
   - 逐个添加数字
   - 在现有排列的每个位置插入新数字
   - 动态构建结果集

2. **实现细节**
   - 从单个元素开始
   - 逐步扩展排列长度
   - 维护中间结果列表

### 复杂度分析
- 时间复杂度：O(n!)
  - n是数组长度
  - 需要生成n!个排列
- 空间复杂度：O(n)
  - 递归深度为n
  - 需要存储中间结果

## 与字符串全排列 II 的区别
1. **输入特点**
   - 全排列：无重复数字
   - 全排列 II：可能有重复

2. **实现复杂度**
   - 全排列：不需要去重
   - 全排列 II：需要处理重复

3. **解法差异**
   - 全排列：直接生成
   - 全排列 II：需要排序和跳过

## 代码实现要点
1. 正确维护已用数字
2. 高效生成排列
3. 合理使用数据结构
4. 优化空间使用

## 优化可能
1. 使用位运算标记
2. 预处理优化查找
3. 并行生成排列
4. 使用迭代器减少内存

## 应用场景
1. 组合优化
2. 路径规划
3. 测试用例生成
4. 密码生成

## 相关题目
1. 全排列 II
2. 字符串的全排列
3. 下一个排列
4. 第k个排列

## 常见错误
1. 未正确回溯
2. 重复使用元素
3. 递归终止条件错误
4. 空间使用过多 