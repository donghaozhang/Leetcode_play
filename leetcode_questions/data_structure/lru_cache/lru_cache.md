# LRU 缓存

## 题目描述
设计和实现一个 LRU (Least Recently Used) 缓存数据结构，它应该支持以下操作：
- get(key)：获取缓存中key对应的值，如果key不存在则返回-1
- put(key, value)：将key-value对放入缓存，如果缓存已满，则删除最久未使用的项

要求：get 和 put 操作的时间复杂度都是 O(1)

## 示例
```python
cache = LRUCache(2)  # 容量为2
cache.put(1, 1)
cache.put(2, 2)
cache.get(1)       # 返回 1
cache.put(3, 3)    # 删除 key 2
cache.get(2)       # 返回 -1 (未找到)
cache.put(4, 4)    # 删除 key 1
cache.get(1)       # 返回 -1 (未找到)
cache.get(3)       # 返回 3
cache.get(4)       # 返回 4
```

## 解题思路

### 哈希表 + 双向链表
为了实现 O(1) 的时间复杂度，我们需要：

1. **数据结构选择**
   - 哈希表：实现 O(1) 的查找
   - 双向链表：实现 O(1) 的插入和删除
   - 结合两者实现 LRU 功能

2. **实现细节**
   - 双向链表按使用时间排序
   - 最近使用的在头部
   - 最久未使用的在尾部
   - 哈希表存储 key 到节点的映射

3. **关键操作**
   - 访问节点时移动到头部
   - 缓存满时删除尾部节点
   - 更新已存在的节点

### 为什么需要双向链表？
- 需要 O(1) 删除任意节点
- 单向链表需要知道前驱节点
- 双向链表可以直接获取前驱节点

### 复杂度分析
- 时间复杂度：O(1)
  - get 操作：O(1)
  - put 操作：O(1)
- 空间复杂度：O(capacity)
  - 存储最多 capacity 个节点
  - 每个节点需要常数空间

## 代码实现要点
1. 正确实现双向链表的操作
2. 维护哈希表和链表的一致性
3. 处理缓存满和缓存命中的情况
4. 使用虚拟头尾节点简化操作
5. 注意更新最近使用的顺序 

### 单链表实现
除了使用双向链表，我们也可以使用单链表实现LRU缓存：

1. **关键思路**
   - 使用单链表存储节点
   - 使用额外的哈希表存储每个节点的前驱节点
   - 通过前驱节点实现O(1)删除

2. **数据结构**
   ```python
   self.cache = {}   # key -> node
   self.prev = {}    # node -> prev_node
   ```

3. **优缺点**
   优点：
   - 节点结构更简单
   - 内存使用更少
   
   缺点：
   - 需要额外的哈希表存储前驱关系
   - 代码实现相对复杂

4. **时间复杂度**
   - 仍然保持O(1)的操作复杂度
   - 但常数因子可能略大

### 实现选择
- 如果内存受限，可以考虑单链表实现
- 如果追求代码简洁性，推荐双向链表实现
- 两种实现在渐近复杂度上是等价的 