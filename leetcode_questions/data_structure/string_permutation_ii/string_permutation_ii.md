# 字符串的全排列 II

## 题目描述
给定一个可能包含重复字符的字符串，返回这个字符串的所有不重复全排列。排列需要按字典序排序。

## 示例
输入: "abb"
输出: ["abb", "bab", "bba"]

## 解题思路

### 方法一：回溯法
1. **核心思想**
   - 使用回溯法生成所有可能的排列
   - 使用Counter处理重复字符
   - 按字典序生成排列

2. **去重策略**
   - 对字符进行排序，确保按字典序生成
   - 在同一层递归中，相同字符只使用一次
   - 使用Counter记录每个字符的可用次数

3. **实现步骤**
   ```python
   # 1. 统计字符频率
   counter = Counter(s)
   
   # 2. 回溯生成排列
   def backtrack(counter, curr):
       if len(curr) == len(s):
           result.append(''.join(curr))
           return
           
       for char in sorted(counter.keys()):
           if counter[char] > 0:
               counter[char] -= 1
               curr.append(char)
               backtrack(counter, curr)
               curr.pop()
               counter[char] += 1
   ```

### 方法二：迭代法
1. **核心思想**
   - 从小到大生成所有排列
   - 使用next_permutation的思想
   - 跳过重复排列

2. **优点**
   - 不需要额外空间存储中间结果
   - 可以提前终止
   - 适合处理大规模数据

### 复杂度分析
- 时间复杂度：O(n! * n)
  - n!是排列数量
  - 每个排列需要O(n)时间生成
- 空间复杂度：O(n)
  - 递归深度或迭代栈深度

## 代码实现要点
1. 正确处理重复字符
2. 维护字典序
3. 高效回溯
4. 优化空间使用

## 应用场景
1. 密码生成
2. 排列组合问题
3. 字符串处理
4. 状态空间搜索

## 相关题目
1. 全排列
2. 下一个排列
3. 字符串的排列
4. 带重复元素的排列

## 常见错误
1. 未正确处理重复字符
2. 字典序错误
3. 回溯状态未恢复
4. 内存使用过多 