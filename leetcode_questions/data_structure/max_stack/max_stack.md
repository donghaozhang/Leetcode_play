# 最大栈问题解析

## 问题描述
设计一个支持以下操作且时间复杂度整体较优的栈，要求实现以下方法：
- **push(x)**：将元素 x 压入栈中。
- **pop()**：移除并返回栈顶元素。
- **top()**：获取栈顶元素。
- **peekMax()**：获取栈中的最大元素。
- **popMax()**：移除并返回栈中的最大元素。如果存在多个相同的最大值，则只移除靠近栈顶的那个。

例如：
```
MaxStack stack = new MaxStack();
stack.push(5);
stack.push(1);
stack.push(5);
stack.top();      // 返回 5
stack.popMax();   // 返回 5
stack.top();      // 返回 1
stack.peekMax();  // 返回 5
stack.pop();      // 返回 1
stack.top();      // 返回 5
```

## 解题思路

### 方法：双栈法（平行栈法）
此方法通过维护两个栈来实现所有操作：
1. **主栈（stack）**：存储所有压入的元素。
2. **辅助栈（max_stack）**：与主栈平行，每个位置记录到该位置为止的最大值。即对于任意索引 i，`max_stack[i] = max(stack[0..i])`。

操作说明：
- **push(x)**：
  - 将 x 压入主栈。
  - 同时，将 `max(x, 当前max_stack栈顶)` 压入辅助栈；如果辅助栈为空，则直接压入 x。
- **pop()**：
  - 分别从主栈和辅助栈弹出栈顶元素。
- **top()**：
  - 直接返回主栈顶元素。
- **peekMax()**：
  - 直接返回辅助栈顶元素，即当前的最大值。
- **popMax()**：
  - 先通过 **peekMax()** 得到当前最大值 `max_val`。
  - 然后需要将主栈中靠近栈顶的那个最大值移除。具体做法是：
    - 弹出主栈中的元素并暂存到一个缓冲栈中，直到遇到栈顶等于 `max_val` 为止。
    - 弹出并移除这个最大值（此时也同步弹出辅助栈的对应值）。
    - 最后将缓冲栈中的元素依次重新压回主栈（重新构建辅助栈）。
  
该方法中，**push, pop, top, peekMax** 都是 O(1) 的，而 **popMax** 在最坏情况下需要 O(n)，这是可以接受的。

## 复杂度分析
- **push(x)**：O(1)
- **pop()**：O(1)
- **top()**：O(1)
- **peekMax()**：O(1)
- **popMax()**：O(n)（最坏情况下需要 O(n) 次 pop 操作） 