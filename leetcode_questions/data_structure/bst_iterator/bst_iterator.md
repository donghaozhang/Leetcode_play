# 二叉搜索树迭代器

## 题目描述
实现一个二叉搜索树迭代器，包含 `hasNext()` 和 `next()` 两个方法。要求：
1. `next()` 返回二叉搜索树中的下一个最小值
2. `hasNext()` 返回是否存在下一个值
3. 调用 `next()` 的时间复杂度是 O(1)
4. 空间复杂度是 O(h)，其中 h 是树的高度

## 示例
```python
# 二叉搜索树:
#       7
#      / \
#     3   15
#        /  \
#       9    20

iterator = BSTIterator(root)
iterator.next()    # 返回 3
iterator.next()    # 返回 7
iterator.hasNext() # 返回 true
iterator.next()    # 返回 9
iterator.hasNext() # 返回 true
iterator.next()    # 返回 15
iterator.hasNext() # 返回 true
iterator.next()    # 返回 20
iterator.hasNext() # 返回 false
```

## 解题思路

### 核心思想
1. **中序遍历**
   - 二叉搜索树的中序遍历是升序序列
   - 使用栈实现迭代式中序遍历
   - 按需生成下一个值

2. **栈的使用**
   - 栈保存待访问的节点
   - 维护最左路径节点
   - 实现O(1)的next()操作

### 实现细节

1. **初始化**
   - 创建空栈
   - 将根节点到最左叶子的路径入栈
   - 栈顶始终是下一个最小值

2. **next() 操作**
   - 弹出栈顶节点（当前最小值）
   - 将右子树的最左路径入栈
   - 返回弹出节点的值

3. **hasNext() 操作**
   - 检查栈是否为空
   - 栈非空表示还有下一个值

### 复杂度分析
- **时间复杂度**
  - next(): 平均O(1)
  - hasNext(): O(1)
  - 初始化: O(h)
- **空间复杂度**: O(h)
  - h是树的高度
  - 栈最多存储一条路径

## 代码实现要点
1. 正确维护栈结构
2. 处理空树情况
3. 高效管理内存
4. 实现迭代器接口

## 优化可能
1. 使用Morris遍历减少空间
2. 预计算部分结果
3. 处理不平衡树
4. 支持双向迭代

## 应用场景
1. 树的遍历
2. 流式处理
3. 惰性求值
4. 内存受限系统

## 相关题目
1. 二叉树的中序遍历
2. 验证二叉搜索树
3. 二叉搜索树的最小值
4. 展平二叉搜索树

## 常见错误
1. 栈管理不当
2. 遗漏边界情况
3. 空间复杂度过高
4. 未正确处理右子树 