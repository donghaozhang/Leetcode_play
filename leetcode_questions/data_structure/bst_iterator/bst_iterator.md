# 二叉搜索树迭代器

## 题目描述
设计一个二叉搜索树的迭代器，实现 `hasNext()` 和 `next()` 两个方法：
- `next()` 返回二叉搜索树中的下一个最小值
- `hasNext()` 返回是否存在下一个值

要求：
1. `next()` 和 `hasNext()` 的平均时间复杂度为 O(1)
2. 空间复杂度为 O(h)，其中 h 是树的高度

## 示例
```
输入:
    7
   / \
  3   15
     /  \
    9    20

操作:
iterator = BSTIterator(root)
iterator.next()    // 返回 3
iterator.next()    // 返回 7
iterator.hasNext() // 返回 true
iterator.next()    // 返回 9
```

## 解题思路

### 1. 栈实现
- 使用栈来模拟递归的中序遍历
- 维护一个从当前节点到最左叶子的路径
- 每次取出栈顶元素时，将其右子树的最左路径入栈

### 2. 关键点
- 初始化时只处理根节点到最左叶子的路径
- 调用 next() 时才处理右子树
- 栈为空时表示遍历结束

### 3. 实现细节
```python
def _leftmost_inorder(self, root):
    while root:
        self.stack.append(root)
        root = root.left
```

## 复杂度分析

### 时间复杂度
- `next()`：平均 O(1)
  - 虽然右子树的处理可能需要 O(h)，但这种情况很少发生
  - 多次操作的平均代价是 O(1)
- `hasNext()`：O(1)
  - 只需检查栈是否为空

### 空间复杂度
- O(h)，其中 h 是树的高度
- 栈中最多存储从根到叶子的一条路径

## 代码实现要点
1. 正确维护栈结构
2. 处理右子树的时机
3. 空树的边界情况
4. 栈的状态管理

## 应用场景
1. 树的遍历控制
2. 惰性计算
3. 流式处理
4. 内存优化

## 常见错误
1. 初始化时遍历整棵树
2. 未正确处理右子树
3. 栈管理不当
4. 边界条件处理错误

## 相关题目
1. 二叉树的中序遍历
2. 展平二叉搜索树
3. 验证二叉搜索树
4. 二叉搜索树的第k小元素

## 优化可能
1. 使用Morris遍历减少空间
2. 预计算部分结果
3. 处理不平衡树
4. 支持双向迭代

## 应用场景
1. 树的遍历
2. 流式处理
3. 惰性求值
4. 内存受限系统

## 相关题目
1. 二叉树的中序遍历
2. 验证二叉搜索树
3. 二叉搜索树的最小值
4. 展平二叉搜索树

## 常见错误
1. 栈管理不当
2. 遗漏边界情况
3. 空间复杂度过高
4. 未正确处理右子树 