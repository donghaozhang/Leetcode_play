# 最大整除子集问题解析

## 问题描述
给定一个由不重复正整数组成的集合，找出其中最大的子集，使得该子集中任意两个元素满足：较小的数可以整除较大的数。如果存在多个答案，返回其中任意一个。

例如：
- 输入: `[1, 2, 3, 4, 5, 6, 7, 8]`
- 输出: `{1, 2, 4, 8}`  
  解释：对于子集 `{1, 2, 4, 8}`，任意两个数之间，较小的数都可以整除较大的数（1|2, 1|4, 1|8, 2|4, 2|8, 4|8）。

## 解题思路

### 动态规划方法
1. **预处理**  
   首先对输入数组进行排序，排序可以保证当 nums[j] 能整除 nums[i]（j < i）时，nums[j] 一定是 nums[i] 的候选前驱。

2. **状态定义**  
   令 `dp[i]` 表示以 `nums[i]` 结尾的最大整除子集的长度。  
   同时维护一个数组 `prev[i]` 记录在构造子集过程中，`nums[i]` 的前驱下标（即在最大子集中排在 `nums[i]` 前面的数）。

3. **状态转移**  
   对于每个位置 `i`，尝试所有位置 `j`（`0 ≤ j < i`），如果 `nums[i] % nums[j] == 0`（满足整除条件）且 `dp[j] + 1 > dp[i]`，则更新：
   ```
   dp[i] = dp[j] + 1
   prev[i] = j
   ```
   这样可以构造出以 `nums[i]` 结尾的最大整除子集。

4. **结果重构**  
   找到 `dp` 数组中的最大值对应的下标，然后利用 `prev` 数组反向重构子集链条。最后返回整个子集。

### 时间和空间复杂度
- **时间复杂度：** O(n²)
- **空间复杂度：** O(n) 