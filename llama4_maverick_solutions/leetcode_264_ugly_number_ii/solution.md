# merge_k_sorted_arrays.md)
- 丑数 II / Ugly Number II [LeetCode 264]

## Problem Description

## Ugly Number II
Write a program to find the `n`-th ugly number.

Ugly numbers are **positive numbers** whose prime factors are limited to `2`, `3`, and `5`.

**Example 1:**
```
Input: n = 10
Output: 12
Explanation: 1, 2, 3, 4, 5, 6, 8, 9, 10, 12 is the sequence of the first 10 ugly numbers.
```
**Example 2:**
```
Input: n = 1
Output: 1
Explanation: 1 is typically treated as an ugly number.
```
**Constraints:**

* `1 <= n <= 1690`

## Solution

**Problem Explanation**
=======================

The problem requires finding the `n`-th ugly number. Ugly numbers are positive numbers whose prime factors are limited to `2`, `3`, and `5`. The sequence of ugly numbers starts with `1`, and the next ugly numbers are generated by multiplying the previous ugly numbers by `2`, `3`, or `5`.

**Step-by-Step Approach**
------------------------

1. **Initialize the first ugly number**: The first ugly number is `1`.
2. **Use a data structure to store the ugly numbers**: We can use a list to store the ugly numbers as we generate them.
3. **Use three pointers to track the next possible ugly numbers**: We need to keep track of the next possible ugly numbers that can be generated by multiplying the previous ugly numbers by `2`, `3`, or `5`. We can use three pointers, `i2`, `i3`, and `i5`, to track the indices of the ugly numbers that need to be multiplied by `2`, `3`, and `5`, respectively.
4. **Generate the next ugly number**: At each step, we generate the next ugly number by taking the minimum of the next possible ugly numbers (`ugly[i2] * 2`, `ugly[i3] * 3`, and `ugly[i5] * 5`).
5. **Update the pointers**: We update the pointers `i2`, `i3`, and `i5` based on which one(s) of the next possible ugly numbers is equal to the generated ugly number.
6. **Repeat steps 4-5 until we have generated `n` ugly numbers**: We continue generating ugly numbers until we have `n` of them.

**Python Solution**
==================

```python
def nthUglyNumber(n: int) -> int:
    """
    Returns the n-th ugly number.

    Args:
    n (int): The index of the ugly number to return.

    Returns:
    int: The n-th ugly number.
    """
    # Initialize the list to store the ugly numbers
    ugly = [1]
    
    # Initialize the pointers for the next possible ugly numbers
    i2, i3, i5 = 0, 0, 0
    
    # Generate the next ugly numbers
    while len(ugly) < n:
        # Calculate the next possible ugly numbers
        next_ugly2, next_ugly3, next_ugly5 = ugly[i2] * 2, ugly[i3] * 3, ugly[i5] * 5
        
        # Generate the next ugly number
        next_ugly = min(next_ugly2, next_ugly3, next_ugly5)
        
        # Add the next ugly number to the list
        ugly.append(next_ugly)
        
        # Update the pointers
        if next_ugly == next_ugly2:
            i2 += 1
        if next_ugly == next_ugly3:
            i3 += 1
        if next_ugly == next_ugly5:
            i5 += 1
    
    # Return the n-th ugly number
    return ugly[-1]

# Test cases
print(nthUglyNumber(10))  # Output: 12
print(nthUglyNumber(1))   # Output: 1
print(nthUglyNumber(1690))  # Output: 2123366400
```

**Time and Space Complexity Analysis**
--------------------------------------

* **Time complexity**: The time complexity of this solution is O(n), where n is the input number. This is because we generate the ugly numbers one by one until we have n of them.
* **Space complexity**: The space complexity of this solution is O(n), where n is the input number. This is because we store the generated ugly numbers in a list of size n.

**Test Cases**
--------------

* `nthUglyNumber(10)` should return `12`
* `nthUglyNumber(1)` should return `1`
* `nthUglyNumber(1690)` should return `2123366400`