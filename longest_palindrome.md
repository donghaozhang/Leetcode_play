# 最长回文子串问题解析

## 问题描述
给定一个字符串 s，找到 s 中最长的回文子串。回文串是正着读和反着读都一样的字符串。

例如：
```
输入: "babad"
输出: "bab" 或 "aba"
解释: "aba" 也是一个有效答案。

输入: "cbbd"
输出: "bb"
```

## 解题思路

### 方法：动态规划
1. **状态定义**  
   `dp[i][j]` 表示子串 s[i:j+1] 是否为回文串。

2. **状态转移方程**  
   ```
   dp[i][j] = true,  if i == j (单个字符)
   dp[i][j] = s[i] == s[j],  if j = i + 1 (两个字符)
   dp[i][j] = s[i] == s[j] && dp[i+1][j-1],  if j > i + 1 (多于两个字符)
   ```

3. **计算顺序**  
   - 由于状态 dp[i][j] 依赖于 dp[i+1][j-1]，因此需要按照子串长度从小到大计算。
   - 对于每个长度，遍历所有可能的起始位置。

### 实现要点
- 从小区间开始计算，逐步扩大到大区间
- 大区间的结果依赖于小区间的结果
- 需要合理安排计算顺序，确保计算大区间时小区间的值已经计算出来
- 注意维护最长回文子串的起始位置和长度

## 复杂度分析
- **时间复杂度**：O(n²)
  - 需要填充 n×n 的动态规划表
  - 每个状态的计算是 O(1) 的
- **空间复杂度**：O(n²)
  - 需要 n×n 的二维数组存储状态 