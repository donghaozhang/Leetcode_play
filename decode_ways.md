# 解码方法问题解析

## 问题描述
给定一个只包含数字的字符串，判断有多少种不同的方式将其解码成字母，其中：
- 'A' -> 1
- 'B' -> 2
- … 
- 'Z' -> 26

例如：
- 输入："12"  
  输出：2  
  解释：可以解码为 "AB"（1,2）或 "L"（12）。
- 输入："226"  
  输出：3  
  解释：可以解码为 "BZ"（2,26）、"VF"（22,6）或 "BBF"（2,2,6）。

## 解题思路

### 动态规划方法
1. **状态定义**  
   定义数组 `dp`，其中 `dp[i]` 表示前 `i` 个字符所能解码的方式数。

2. **初始条件**  
   - 空字符串可以视为一种解码方式，所以 `dp[0] = 1`。
   - 如果字符串首字符为非 '0'，则 `dp[1] = 1`；否则无合法解码（返回 0）。

3. **状态转移方程**  
   对于位置 `i`（1-indexed，对应字符串下标 `i-1`）：
   - **单个数字**：如果 `s[i-1]` 不为 '0'，则可以单独解码，`dp[i] += dp[i-1]`。
   - **两个数字**：如果 `s[i-2:i]` 构成的数字介于 10 到 26 之间，则可以将这两个数字一起解码，`dp[i] += dp[i-2]`。

   公式描述：
   ```
   dp[i] = { dp[i-1] (如果 s[i-1] != '0') } + { dp[i-2] (如果 10 <= int(s[i-2:i]) <= 26) }
   ```

4. **返回结果**  
   最终返回 `dp[n]`，其中 `n` 是字符串的长度。

### 时间和空间复杂度
- **时间复杂度：** O(n)，只需遍历字符串一次。
- **空间复杂度：** O(n)，用于存储 dp 数组（可通过滚动数组将空间复杂度降低到 O(1)）。

## 示例说明
以 "226" 为例：
- 初始化：dp[0]=1，dp[1] = 1（"2" 可解码）。
- i = 2：  
  - 考察单个字符 "2"，dp[2] += dp[1] → dp[2] = 1  
  - 考察两个字符 "22"，有效（10 ≤ 22 ≤ 26），dp[2] += dp[0] → dp[2] = 2
- i = 3：  
  - 考察单个字符 "6"，dp[3] += dp[2] → dp[3] = 2  
  - 考察两个字符 "26"，有效，dp[3] += dp[1] → dp[3] = 3

因此，"226" 的解码方式共有 3 种。 