# 最小栈问题解析

## 问题描述
设计一个支持以下操作且时间复杂度均为 O(1) 的栈：
- **push(x)**：将元素 x 压入栈中。
- **pop()**：移除栈顶元素。
- **top()**：获取栈顶元素。
- **getMin()**：检索栈中的最小元素。

例如：
```
MinStack stack = new MinStack();
stack.push(-2);
stack.push(0);
stack.push(-3);
stack.getMin();   // 返回 -3
stack.pop();
stack.top();      // 返回 0
stack.getMin();   // 返回 -2
```

## 解题思路

### 方法：双栈实现
为了解决在 O(1) 内获取最小元素的问题，我们通常采用两个栈：
- **主栈（stack）**：用于存储所有压入的元素。
- **辅助栈（min_stack）**：用于存储当前对应的最小元素。

具体方案：
1. 当执行 **push(x)** 操作时：
   - 将 x 压入主栈中；
   - 同时，如果辅助栈为空或者 x 小于等于辅助栈顶，则将 x 也压入辅助栈中。
2. 当执行 **pop()** 操作时：
   - 弹出主栈顶元素；
   - 如果弹出元素和辅助栈顶元素相等，则辅助栈也弹出。
3. **top()** 返回主栈栈顶。
4. **getMin()** 返回辅助栈栈顶元素（即当前栈中的最小值）。

### 和堆的区别
- **最小栈（Min Stack）**：  
  - 主要是扩展普通栈的功能，除了支持 LIFO（后进先出）操作外，还能在 O(1) 时间内获取栈中的最小元素。  
  - 它只允许删除栈顶元素，顺序上受限于栈的结构。

- **堆（Min Heap）**：  
  - 堆是一种完全二叉树，通常用于实现优先队列，可以在 O(1) 时间内找到最小元素，但插入和删除操作一般需要 O(log n)。  
  - 堆没有 LIFO 的顺序限制，适用于需要频繁查找全局最小值或者排序操作的场景。

总结来说，最小栈是为了在保持栈的基本操作的同时获得 O(1) 的最小值查询，而堆则是一个通用的优先队列，不保证栈式的操作顺序。

## 复杂度分析
- **push(x)**：O(1)
- **pop()**：O(1)
- **top()**：O(1)
- **getMin()**：O(1) 