# merge_k_sorted_arrays.md)
- 丑数 II / Ugly Number II [LeetCode 264]

## Problem Description

```markdown
## 264. Ugly Number II

**Medium**

An **ugly number** is a positive integer whose prime factors are limited to `2`, `3`, and `5`.

Given an integer `n`, return *the* `n^th` ***ugly number***.

**Example 1:**

**Input:** n = 10
**Output:** 12
**Explanation:** [1, 2, 3, 4, 5, 6, 8, 9, 10, 12] is the sequence of the first 10 ugly numbers.

**Example 2:**

**Input:** n = 1
**Output:** 1
**Explanation:** 1 has no prime factors, therefore all of its prime factors are limited to 2, 3, and 5.

**Constraints:**

*   `1 <= n <= 1690`
```

## Solution

Okay, let's break down the "Ugly Number II" problem (LeetCode 264).

**1. Explanation of the Problem**

The problem asks us to find the *n*-th number in a sequence of "ugly numbers". An ugly number is defined as a positive integer whose only prime factors are 2, 3, and 5. The sequence starts with 1. We need to generate these numbers in ascending order and return the one at the *n*-th position.

For example:
- The first few ugly numbers are: 1, 2, 3, 4 (2\*2), 5, 6 (2\*3), 8 (2\*2\*2), 9 (3\*3), 10 (2\*5), 12 (2\*2\*3), ...
- If `n = 10`, the 10th ugly number is 12.

**2. Step-by-Step Approach**

A naive approach would be to check every integer starting from 1, see if it's ugly, and count until we find the *n*-th one. However, checking if a number is ugly involves prime factorization, which can be slow, and ugly numbers become increasingly sparse. This approach would be too inefficient for the given constraints (`n <= 1690`).

A more efficient approach relies on the definition: every ugly number (except 1) must be formed by multiplying a *previous* ugly number by 2, 3, or 5.

We can build the sequence of ugly numbers iteratively:
1.  Start with the first ugly number: `1`.
2.  The subsequent ugly numbers must be generated by multiplying existing ugly numbers by 2, 3, or 5.
3.  We need to find the *smallest* number among all possible `ugly_number * 2`, `ugly_number * 3`, `ugly_number * 5` candidates that hasn't been added to our sequence yet.

This suggests a dynamic programming or a multi-pointer approach:

*   **Initialization:**
    *   Create a list or array `ugly_numbers` of size `n` to store the first `n` ugly numbers.
    *   Initialize the first ugly number: `ugly_numbers[0] = 1`.
    *   Initialize three pointers: `p2 = 0`, `p3 = 0`, `p5 = 0`. These pointers will keep track of the index in `ugly_numbers` for the *next* number to be multiplied by 2, 3, and 5, respectively.

*   **Iteration:**
    *   Iterate from `i = 1` to `n - 1` to find the remaining ugly numbers.
    *   In each iteration `i`, we need to find the `(i+1)`-th ugly number (which will be stored at `ugly_numbers[i]`).
    *   Calculate the next potential candidates by multiplying the numbers at the current pointer positions by their respective factors:
        *   `next_ugly_2 = ugly_numbers[p2] * 2`
        *   `next_ugly_3 = ugly_numbers[p3] * 3`
        *   `next_ugly_5 = ugly_numbers[p5] * 5`
    *   The next ugly number `ugly_numbers[i]` is the minimum of these three candidates:
        *   `ugly_numbers[i] = min(next_ugly_2, next_ugly_3, next_ugly_5)`
    *   **Crucially**, we need to advance the pointer(s) corresponding to the factor(s) that generated the minimum value. If multiple factors generate the same minimum value (e.g., 6 = 2\*3 = 3\*2), we must advance *all* corresponding pointers to avoid duplicates and ensure we consider the next multiple for that factor.
        *   If `ugly_numbers[i] == next_ugly_2`, increment `p2`.
        *   If `ugly_numbers[i] == next_ugly_3`, increment `p3`.
        *   If `ugly_numbers[i] == next_ugly_5`, increment `p5`.

*   **Result:**
    *   After the loop finishes, `ugly_numbers[n - 1]` will contain the *n*-th ugly number.

**Why this works:**
This approach ensures that we always generate the next smallest ugly number. At each step `i`, `ugly_numbers[p2] * 2`, `ugly_numbers[p3] * 3`, and `ugly_numbers[p5] * 5` represent the smallest possible ugly numbers that can be formed by multiplying by 2, 3, and 5 respectively, using ugly numbers we have *already found* but haven't used for that specific factor yet. By taking the minimum, we guarantee we pick the overall smallest next ugly number. Advancing the pointers ensures we consider the *next* multiple for the factor(s) used.

**3. Python Solution**

```python
import heapq # Although the DP approach is better, let's keep the import for context if needed

class Solution:
    def nthUglyNumber(self, n: int) -> int:
        """
        Finds the nth ugly number using a dynamic programming approach.

        An ugly number is a positive integer whose prime factors are limited to 2, 3, and 5.

        Args:
            n: The position of the desired ugly number (1-based index).

        Returns:
            The nth ugly number.
        """
        if n <= 0:
            return 0 # Or raise an error based on constraints/expectations
        if n == 1:
            return 1

        # Initialize DP array to store ugly numbers
        ugly_numbers = [0] * n
        ugly_numbers[0] = 1

        # Initialize pointers for factors 2, 3, and 5
        p2 = 0
        p3 = 0
        p5 = 0

        for i in range(1, n):
            # Calculate the next potential ugly numbers
            next_ugly_2 = ugly_numbers[p2] * 2
            next_ugly_3 = ugly_numbers[p3] * 3
            next_ugly_5 = ugly_numbers[p5] * 5

            # Find the minimum of the candidates
            next_ugly = min(next_ugly_2, next_ugly_3, next_ugly_5)
            ugly_numbers[i] = next_ugly

            # Advance the pointers for the factors that generated the minimum
            # Use separate 'if' statements, not 'elif', because multiple
            # factors might produce the same minimum (e.g., 6 = 2*3 = 3*2)
            if next_ugly == next_ugly_2:
                p2 += 1
            if next_ugly == next_ugly_3:
                p3 += 1
            if next_ugly == next_ugly_5:
                p5 += 1

        # The nth ugly number is the last element in the array
        return ugly_numbers[n - 1]

# --- Test Cases ---

solver = Solution()

# Example 1
n1 = 10
expected1 = 12
result1 = solver.nthUglyNumber(n1)
print(f"Input: n = {n1}")
print(f"Output: {result1}")
print(f"Expected: {expected1}")
print(f"Pass: {result1 == expected1}\n")

# Example 2
n2 = 1
expected2 = 1
result2 = solver.nthUglyNumber(n2)
print(f"Input: n = {n2}")
print(f"Output: {result2}")
print(f"Expected: {expected2}")
print(f"Pass: {result2 == expected2}\n")

# Additional Test Cases
n3 = 7
expected3 = 8 # Sequence: 1, 2, 3, 4, 5, 6, 8
result3 = solver.nthUglyNumber(n3)
print(f"Input: n = {n3}")
print(f"Output: {result3}")
print(f"Expected: {expected3}")
print(f"Pass: {result3 == expected3}\n")

n4 = 11
expected4 = 15 # Sequence: 1, 2, 3, 4, 5, 6, 8, 9, 10, 12, 15
result4 = solver.nthUglyNumber(n4)
print(f"Input: n = {n4}")
print(f"Output: {result4}")
print(f"Expected: {expected4}")
print(f"Pass: {result4 == expected4}\n")

n5 = 1690 # Max constraint
expected5 = 2123366400 # Known result for n=1690
result5 = solver.nthUglyNumber(n5)
print(f"Input: n = {n5}")
print(f"Output: {result5}")
print(f"Expected: {expected5}")
print(f"Pass: {result5 == expected5}\n")

```

**Complexity Analysis:**

*   **Time Complexity:** O(n)
    *   We iterate through the loop `n-1` times to fill the `ugly_numbers` array.
    *   Inside the loop, we perform a constant number of operations: three multiplications, one `min` operation, assignments, and pointer increments.
    *   Therefore, the total time complexity is directly proportional to `n`.

*   **Space Complexity:** O(n)
    *   We use an array `ugly_numbers` of size `n` to store the sequence of ugly numbers.
    *   The space used by the pointers (`p2`, `p3`, `p5`) and temporary variables (`next_ugly_2`, etc.) is constant, O(1).
    *   Thus, the dominant factor for space is the array, resulting in O(n) space complexity.

**4. Test Cases**

Here are some test cases to verify the solution:

1.  **n = 1:**
    *   Input: `n = 1`
    *   Expected Output: `1`
    *   Reason: The first ugly number is 1.
2.  **n = 10:**
    *   Input: `n = 10`
    *   Expected Output: `12`
    *   Reason: The sequence is [1, 2, 3, 4, 5, 6, 8, 9, 10, 12].
3.  **n = 7:**
    *   Input: `n = 7`
    *   Expected Output: `8`
    *   Reason: The sequence is [1, 2, 3, 4, 5, 6, 8].
4.  **n = 11:**
    *   Input: `n = 11`
    *   Expected Output: `15`
    *   Reason: The sequence is [1, 2, 3, 4, 5, 6, 8, 9, 10, 12, 15].
5.  **n = 1690 (Max Constraint):**
    *   Input: `n = 1690`
    *   Expected Output: `2123366400` (This is the known correct value)
    *   Reason: Tests the performance and correctness for the largest possible input.
6.  **n = 6:**
    *   Input: `n = 6`
    *   Expected Output: `6`
    *   Reason: Tests the case where the minimum is generated by multiple factors (6 = 2\*3 = 3\*2), ensuring pointers `p2` and `p3` are correctly advanced.

The provided Python code includes these test cases and demonstrates how to run them.