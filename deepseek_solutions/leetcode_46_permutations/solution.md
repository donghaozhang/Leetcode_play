# bst_iterator.md)
- 全排列 / Permutations [LeetCode 46]

## Problem Description

### Problem Description:

**46. Permutations**

Given an array `nums` of distinct integers, return all the possible permutations. You can return the answer in any order.

**Example 1:**
```
Input: nums = [1,2,3]
Output: [[1,2,3],[1,3,2],[2,1,3],[2,3,1],[3,1,2],[3,2,1]]
```

**Example 2:**
```
Input: nums = [0,1]
Output: [[0,1],[1,0]]
```

**Example 3:**
```
Input: nums = [1]
Output: [[1]]
```

**Constraints:**
- `1 <= nums.length <= 6`
- `-10 <= nums[i] <= 10`
- All the integers of `nums` are unique.

## Solution

### Explanation of the Problem:
The problem requires generating all possible permutations of a given array of distinct integers. A permutation is an arrangement of all the elements of the array in every possible order. For example, for the array `[1,2,3]`, the permutations are all the possible ways to arrange these three numbers, resulting in 6 different sequences.

### Approach:
To solve this problem, we can use a backtracking approach. Backtracking is a systematic way to iterate through all possible configurations of a search space. Here's the step-by-step approach:

1. **Base Case**: If the current permutation being built has the same length as the input array, add it to the result list.
2. **Recursive Case**: For each number in the array that hasn't been used yet in the current permutation:
   - Add the number to the current permutation.
   - Mark the number as used.
   - Recursively build the permutation with the remaining unused numbers.
   - Backtrack by removing the number from the current permutation and marking it as unused to explore other possibilities.

This approach ensures that every possible permutation is generated by systematically exploring all possible choices at each step.

### Solution Code:
```python
class Solution:
    def permute(self, nums):
        def backtrack(start, end):
            if start == end:
                result.append(nums[:])
            for i in range(start, end):
                nums[start], nums[i] = nums[i], nums[start]
                backtrack(start + 1, end)
                nums[start], nums[i] = nums[i], nums[start]
        
        result = []
        backtrack(0, len(nums))
        return result

# Test cases
solution = Solution()
print(solution.permute([1,2,3]))  # Output: [[1,2,3],[1,3,2],[2,1,3],[2,3,1],[3,1,2],[3,2,1]]
print(solution.permute([0,1]))     # Output: [[0,1],[1,0]]
print(solution.permute([1]))       # Output: [[1]]
```

### Explanation of the Code:
1. **Backtrack Function**: The `backtrack` function is defined to generate permutations by swapping elements. 
   - **Parameters**: `start` is the current position being filled in the permutation, and `end` is the length of the array.
   - **Base Case**: When `start` equals `end`, the current permutation (a copy of `nums`) is added to the result.
   - **Recursive Case**: For each index `i` from `start` to `end-1`, swap the elements at `start` and `i`, then recursively call `backtrack` for the next position (`start + 1`). After the recursive call, swap back to backtrack and explore other possibilities.

2. **Initialization**: The `result` list is initialized to store all permutations. The `backtrack` function is called initially with `start = 0` and `end = len(nums)`.

3. **Test Cases**: The solution is tested with three different inputs to verify correctness.

### Time and Space Complexity:
- **Time Complexity**: O(N * N!), where N is the number of elements in `nums`. There are N! permutations, and each permutation takes O(N) time to construct.
- **Space Complexity**: O(N!) to store all permutations. The recursion stack uses O(N) space, but the dominant factor is the storage for the permutations.

This approach efficiently generates all permutations using backtracking, ensuring that every possible arrangement is explored and collected.