# 骑士最短路径 II 问题解析

## 问题描述
在一个 m×n 的棋盘上，给定骑士（马）的起始位置和目标位置，求骑士到达目标位置的最少步数。
与普通跳马问题不同，这次骑士只能向右移动，即只能使用以下四种走法：
- 向右走 1 格，向上/下走 2 格
- 向右走 2 格，向上/下走 1 格

例如：
```
输入:
[[0,0,0,0],
 [0,0,0,0],
 [0,0,0,0]]
source = [2,0]
destination = [2,2]
输出: 2
解释:
[2,0]->[0,1]->[2,2]
```

## 解题思路

### 方法：BFS + 方向限制
由于骑士只能向右移动，这个问题比普通跳马问题更简单：
1. 移动方向只有 4 种（而不是 8 种）
2. 不会出现环，因为只能向右移动
3. 可以提前判断是否可达（如果终点在起点左边，则一定不可达）

1. **移动方向**  
   骑士可以移动的 4 个方向用坐标差表示：
   ```python
   DIRECTIONS = [
       (1, -2),  # 右1上2
       (1, 2),   # 右1下2
       (2, -1),  # 右2上1
       (2, 1)    # 右2下1
   ]
   ```

2. **BFS 实现步骤**
   - 使用队列存储待访问的位置
   - 由于只能向右移动，不需要记录已访问位置（不会重复访问）
   - 按层遍历，每一层代表移动的步数
   - 当找到目标位置时返回当前步数

3. **提前判断**
   - 如果终点的列号小于起点的列号，直接返回 -1
   - 如果起点等于终点，直接返回 0

## 复杂度分析
- **时间复杂度**：O(m×n)
  - m、n 为棋盘的行数和列数
  - 每个位置最多被访问一次
- **空间复杂度**：O(min(m,n))
  - 队列中最多存储一列的所有可能位置

## 实现要点
1. 注意方向限制，只能向右移动
2. 不需要访问集合（因为不会重复访问）
3. 可以提前判断不可能的情况
4. 注意边界检查，确保不会超出棋盘范围 